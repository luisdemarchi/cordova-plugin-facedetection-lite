<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<title>oi</title>
	<script type="text/javascript" src="./pico.min.js"></script>
	<script type="text/javascript" src="./cordova.js"></script>
	<!--<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">-->
</head>

<body>
	<video id="cameraPreview" playsinline=1 style="display: none;"></video>
	<canvas id="cameraIosPreview" width=640 height=480 style="display: none;"></canvas>
	<canvas id="canvasPreview" width="300" height="300"></canvas>
	<canvas id="facePreview" width="400" height="400" style="width: 305px; height: inherit;"></canvas>

	<script type="text/javascript">
		var cameraPreview = document.getElementById("cameraPreview");
		var cameraIosPreview = document.getElementById("cameraIosPreview");
		var canvasPreview = document.getElementById("canvasPreview");

		var facePreviewCtx = document.getElementById("facePreview").getContext("2d", { alpha: false });

		canvasPreview.style.width = "150px";
		canvasPreview.style.height = "inherit";
		var height = 0;
		var width = 0;
		var scale = 0;
		var heightMini = 0;
		var widthMini = 0;
		var faceBox = {
			size: 0,
			x: 0,
			y: 0
		};

		var initialized = false;
		var isIosApp;

		document.addEventListener(
			"deviceready",
			function () {
				isIosApp = window.device.platform === "iOS";
				console.log("open");
				start();
			},
			false
		);

		function createLoop() {
			// requestAnimationFrame = memory leak problem 
			// requestAnimationFrame(loop);

			processfn();
			window.setTimeout(function () {
				createLoop();
			}, 20);


		}


		function camvas() {
			if (isIosApp) {
				cameraIosPreview.style.display = "inline";
				let options = {
					// canvas: {
					// 	width: 640,
					// 	height: 480
					// },
					// capture: {
					// 	width: 640,
					// 	height: 480
					// },
					use: 'file',
					fps: 15,
					hasThumbnail: false,
					cameraFacing: "front",
					onAfterDraw: function (frame) {
						cameraIosPreview.style.width = "150px";
						cameraIosPreview.style.height = "inherit";
						handleCameraSize();
					}
				};
				window.plugin.CanvasCamera.start(options);
				createLoop();
				updateFacePreview();
			} else {

				cameraPreview.autoplay = 1;
				cameraPreview.style.display = "inline";
				// The callback happens when we are starting to stream the video.
				navigator.mediaDevices.getUserMedia({ video: true, audio: false }).then(function (stream) {
					// Yay, now our webcam input is treated as a normal video and
					// we can start having fun
					cameraPreview.srcObject = stream
					handleCameraSize();
					// Let's start drawing the canvas!
					createLoop();
					updateFacePreview();
				}, function (err) {
					throw err
				})
			}
		}

		async function handleCameraSize() {
			height = cameraIosPreview.height;
			width = cameraIosPreview.width;
			let maxSize = Math.max(width, height);
			scale = 90 / maxSize;

			if (!isIosApp) {
				await new Promise(
					resolve => (this.cameraPreview.onloadedmetadata = resolve)
				);
				this.cameraIosPreview.width = this.cameraPreview.videoWidth;
				this.cameraIosPreview.height = this.cameraPreview.videoHeight;
			}

			if (faceBox.size == 0 && widthMini == 0) {
				let minSize = Math.min(width, height);
				faceBox.size = Math.floor(minSize * scale);

				heightMini = Math.floor(height * scale);
				widthMini = Math.floor(width * scale);

				canvasPreview.width = widthMini;
				canvasPreview.height = heightMini;
			}

		}

		function start() {
			if (initialized)
				return; // if yes, then do not initialize everything again

			cordova.plugins.facedetector.initFaceDetector(30, "./facefinder", function (result) {
				console.log('* cascade loaded');
			});

			if (isIosApp) {
				window.plugin.CanvasCamera.initialize(cameraIosPreview);
			}

			var mycamvas = new camvas();

			initialized = true;
		}

		function processfn() {


			// countTest += 1;
			if (widthMini > 0) {
				var canvasPreviewCtx = canvasPreview.getContext("2d", { alpha: false });

				canvasPreviewCtx.drawImage(
					isIosApp ? cameraIosPreview : cameraPreview,
					0, 0, width, height,
					0, 0, widthMini, heightMini
				);
				var rgba = canvasPreviewCtx.getImageData(0, 0, widthMini, heightMini).data;
				// console.log(rgba);
				// cordova.plugins.facedetector.test1(rgba, widthMini, heightMini, function (result) {
				//     // console.log('* teste executado');
				// });
				let minSizeFace = widthMini * 0.3;
				let maxSizeFace = widthMini * 1.3;
				let iouthreshold = 0.2;
				cordova.plugins.facedetector.detections(rgba, widthMini, heightMini, minSizeFace, maxSizeFace, iouthreshold, function (dets) {
					//detect unique face
					var greaterFace = Math.max.apply(
						Math,
						dets.map(function (o) {
							return o[2];
						})
					);
					var box = dets.find(function (element) {
						return element[2] == greaterFace && element[3] !== undefined;
					});
					// check the detection score
					// if it's above the threshold, draw it
					// (the constant 50.0 is empirical: other cascades might require a different one)
					if (box !== undefined) {

						console.log("chegou: " + box[3]);
					}
					if (box !== undefined) {
						canvasPreviewCtx.beginPath();
						canvasPreviewCtx.arc(box[1], box[0], box[2] / 2, 0, 2 * Math.PI, false);
						canvasPreviewCtx.lineWidth = 1;
						canvasPreviewCtx.strokeStyle = 'red';
						canvasPreviewCtx.stroke();

						faceBox = {
							x: _weightedMean(
								[faceBox.x, box[1] - box[2] / 2],
								[0.4, 0.1]
							),
							y: _weightedMean(
								[faceBox.y, box[0] - box[2] / 2],
								[0.4, 0.1]
							),
							size: _weightedMean(
								[faceBox.size, box[2]],
								[0.4, 0.1]
							)
						}
					}
					greaterFace = null;
					box = null;
				});

			}
		}

		var updateFacePreview = function () {
			var loop = function () {
				if (faceBox.x > 0) {
					var faceSizeOriginal = document.createElement('canvas');
					faceSizeOriginal.width = parseInt(faceBox.size / scale);
					faceSizeOriginal.height = parseInt(faceBox.size / scale);
					var faceSizeOriginalCtx = faceSizeOriginal.getContext("2d", { alpha: false });
					faceSizeOriginalCtx.drawImage(
						isIosApp ? cameraIosPreview : cameraPreview,
						parseInt(faceBox.x / scale),
						parseInt(faceBox.y / scale),
						parseInt(faceBox.size / scale),
						parseInt(faceBox.size / scale),
						0,
						0,
						parseInt(faceBox.size / scale),
						parseInt(faceBox.size / scale),
					);

					facePreviewCtx.drawImage(
						faceSizeOriginal,
						0, 0, faceSizeOriginal.width, faceSizeOriginal.height,
						0, 0, 400, 400
					);

					cameraIosPreviewTemp = null;
					faceSizeOriginal = null;
					faceSizeOriginalCtx = null;
					facePreview = null;
					delete faceSizeOriginalCtx;
					delete faceSizeOriginal;
					delete facePreview;
					delete cameraIosPreviewTemp;
				}

				requestAnimationFrame(loop);
			}
			requestAnimationFrame(loop);
		}

		function _sumArrayValues(values) {
			return values.reduce((p, c) => p + c, 0);
		}

		function _weightedMean(factorsArray, weightsArray) {
			return (
				this._sumArrayValues(
					factorsArray.map((factor, index) => factor * weightsArray[index])
				) / this._sumArrayValues(weightsArray)
			);
		}
	</script>
</body>

</html>